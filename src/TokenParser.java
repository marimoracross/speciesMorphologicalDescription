import java.sql.*;


public class TokenParser {
    /* Class to manage Tokens generated by the dependency parser */
	/*
	 * A Tokenparser instance is created from the following SQL"
	 * select t.id, t.taxon_description_id, t.line_number, t.sequence, t.token, t.lemma, t.pos, t.tag1, t.tag2, k.type, " +
	 *      k.english_lemma, o.category, o.term_id " +
     *      from text.token_tree t left join text.knowledge k  on trim(k.phrase) = trim(t.token) " +
     *      left join text.oto o on trim(k.english_lemma) = trim(o.term) " +
     *      where t.book_id = ? and t.taxon_description_id = ? and  t.line_number = ? and t.sequence = ? and " +
     *             trim(t.token) = ? and  trim(t.pos) = ?  and trim(t.tag1) = ?  and trim(t.tag2) = ? 
	 * 
	 */
	
	
	
	Integer tokenId;      // Database sequence automatic assigned to the token in text.token
	Integer taxonDescriptionId;  // Token's Taxon Description Record ID 
	Integer lineNumber;  // Line number associated to Taxon Description Record ID
	String  wordForm;  // Word as it appear in the document
	String  wordLemma; // Lemma of wordForm
	String  wordTag;   // POS Tag assigned to wordForm
	String  tag1;  // 
	String  tag2; 
	Integer sequence;   // Chunk Sequence 
	Integer bookId;   // Book identifier 
	String  knowledgeType; // Knowledge.type
	String  ontologyCategory; // a list of OntologyCategory separated by "," 
	String  ontologyId; // 
	Integer tokenTreeId; // Id used during the semantic analysis to evaluate if v_characterId a token was included as a character

	

	public TokenParser (Integer p_token_id, Integer p_taxon_descrition_id, Integer  p_line_number,
			String p_form, String p_lemma, String p_tag, String p_tag1, String p_tag2, Integer p_seq, Integer p_book_id) {
		// Token_tree records
		
		tokenId = p_token_id;
		taxonDescriptionId = p_taxon_descrition_id;
		lineNumber = p_line_number;
		wordForm = p_form;
		wordLemma = p_lemma;
		wordTag = p_tag;
		tag1 = p_tag1;
		tag2 =p_tag2;
		sequence = p_seq;
		bookId = p_book_id;
		knowledgeType = null;
		ontologyCategory = null;
		ontologyId = null;
		tokenTreeId = null;
	}
	
	public TokenParser (Integer p_token_id, Integer p_taxon_descrition_id, Integer  p_line_number,
			String p_form, String p_lemma, String p_tag, String p_tag1, String p_tag2,  Integer p_book_id) {
		// Token_tree records
		
		tokenId = p_token_id;
		taxonDescriptionId = p_taxon_descrition_id;
		lineNumber = p_line_number;
		wordForm = p_form;
		wordLemma = p_lemma;
		wordTag = p_tag;
		tag1 = p_tag1;
		tag2 =p_tag2;
		sequence = null;
		bookId = p_book_id;
		knowledgeType = null;
		ontologyCategory = null;
		ontologyId = null;
		tokenTreeId = null;
	}
	
	public TokenParser (Integer p_token_id, Integer p_taxon_descrition_id, Integer  p_line_number,
			String p_form, String p_lemma, String p_tag, String p_tag1, String p_tag2, Integer p_sequence, Integer p_book_id,
			String p_knowledgeType, String p_ontologyCategory, String p_ontologyId) {
		// Token_tree records
		
		tokenId = p_token_id;
		taxonDescriptionId = p_taxon_descrition_id;
		lineNumber = p_line_number;
		wordForm = p_form;
		wordLemma = p_lemma;
		wordTag = p_tag;
		tag1 = p_tag1;
		tag2 =p_tag2;
		sequence = p_sequence;
		bookId = p_book_id;
		knowledgeType = p_knowledgeType;
		ontologyCategory = p_ontologyCategory;
		ontologyId = p_ontologyId;
		tokenTreeId = null;
	}
	
	public TokenParser (Integer p_token_id, Integer p_taxon_descrition_id, Integer  p_line_number,
			String p_form, String p_lemma, String p_tag, String p_tag1, String p_tag2, Integer p_sequence, Integer p_book_id,
			String p_knowledgeType, String p_ontologyCategory, String p_ontologyId, Integer p_tokenTreeId) {
		// Token_tree records
		
		tokenId = p_token_id;
		taxonDescriptionId = p_taxon_descrition_id;
		lineNumber = p_line_number;
		wordForm = p_form;
		wordLemma = p_lemma;
		wordTag = p_tag;
		tag1 = p_tag1;
		tag2 =p_tag2;
		sequence = p_sequence;
		bookId = p_book_id;
		knowledgeType = p_knowledgeType;
		ontologyCategory = p_ontologyCategory;
		ontologyId = p_ontologyId;
		tokenTreeId = p_tokenTreeId;
	}
	
	
	public void setTokenTreeId (Integer p_tokenTreeId) {
		this.tokenTreeId = p_tokenTreeId;
	}
	
	public void setOntologyCategory (String p_category) {
		this.ontologyCategory = p_category;
	}
	
	
	public Integer getTokenId () {
		return (this.tokenId);
	}
	
	public Integer getTaxonDescriptionId () {
		return (this.taxonDescriptionId);
	}
	
	public Integer getLineNumber () {
		return (this.lineNumber);
	}
	
	public String getWordForm () {
		return (this.wordForm);
	}
	
	public String getWordLemma() {
		return (this.wordLemma);
	}
	
	public String getWordTag () {
		return (this.wordTag);
	}
	
	public String getTag1 () {
		return (this.tag1);
	}
	
	public String getTag2 () {
		return (this.tag2);
	}
	
	public Integer getSequence () {
		return (this.sequence);
	}
	
	public Integer getBookId () {
		return (this.bookId);
	}
	
	public String getKnowledgeType () {
		return (this.knowledgeType);
	}
	
	public String getOntologyCategory () {
		return (this.ontologyCategory);
	}
	
	public String getOntologyId () {
		return (this.ontologyId);
	}
	
	public Integer getTokenTreeId () {
		return (this.tokenTreeId);
	}
	
	
	public Integer distance (Connection conn, TokenParser p_previousToken){
		/* - Description: return the number of characters between 2 tokens (type TokenParser) in a chunk.  
		 * 
	     * - Revision History:
	     *     29/07/2015 - Maria Aux. Mora
	     *     
	     * - Arguments (input / output):
	     *      TokenParser p_previousToken, this   // Tokens to be compared
	     * 
	     * - Return Values:
	     *     - The number of character between both tokens in a chunk. 9999 if a token does not exist. 
	*/
		
		Integer v_distance = 9999;
		Integer x,y;
		String word1, word2, temp;
		Integer indexOfCurrentTokenWordForm;
		Integer indexOfPreviousTokenWordForm;
		Integer indexWord1 = 0;
		Integer indexWord2 = 0;
		
		if (p_previousToken != null) {
		   String chunkContents = TextDatabase.SelectChunkContents(conn, p_previousToken.getTaxonDescriptionId(), p_previousToken.getLineNumber(),
				                                 p_previousToken.getSequence()) ;
	       //Return chunkContents.indexOf(this.getWordForm()) if this.getWordForm() has only one repetition. If not generate the real index.
		   indexOfCurrentTokenWordForm = TextDatabase.indexOfWordInChunk (conn, chunkContents, this, false);		   
		   //Return chunkContents.indexOf( p_previousToken.getWordForm()
		   indexOfPreviousTokenWordForm = TextDatabase.indexOfWordInChunk(conn, chunkContents, p_previousToken, true);
		   
		   if ( (chunkContents != null ) && (this.getWordForm() != null) && (p_previousToken.getWordForm()!=null) && 
				!(this.getWordForm().equals(p_previousToken.getWordForm())) ) {
	    	   if (indexOfCurrentTokenWordForm < indexOfPreviousTokenWordForm){ 
		    	  word1 = this.getWordForm();
	    	      word2 = p_previousToken.getWordForm();
	    	      indexWord1 = indexOfCurrentTokenWordForm;
	    	      indexWord2 = indexOfPreviousTokenWordForm;
	    	   }
	    	   else { 
	    		   word2 = this.getWordForm();
	    		   word1 = p_previousToken.getWordForm();
	    	   	   indexWord2 = indexOfCurrentTokenWordForm;
		    	   indexWord1 = indexOfPreviousTokenWordForm;
	           }
	    	   
	    	   //  If both word are part of chunkContents
		       if (indexWord1 >= 0 && indexWord2>= 0) {
/*		    	   x= chunkContents.indexOf(word1) + word1.length();
		    	   temp = chunkContents.substring(x+1);  // to avoid repeated words, example "ancho-avoides a avoides".
		     	   y= x + 1 + temp.indexOf(word2);
*/			
		    	   x= indexWord1 + word1.length();
		    	   if (x < chunkContents.length()) {
			    	   temp = chunkContents.substring(x+1);  // to avoid repeated words, example "ancho-avoides a avoides".
			     	   y= x + 1 + temp.indexOf(word2);
			           System.out.println(" x, y "+  x + "  " + y + "  " + chunkContents + "  " + word1 + "   w2 "+ word2);
			        
		
			    	   v_distance = chunkContents.substring(x, y).trim().length();
			       } 
			   }
		  }
		}   
		return (v_distance);
	}
	
	
	public boolean isAdjective(){
/* - Description: return true if current tokenParser is an adjective.
 *        Current tokenParser is an adjective if:
 *          - If ontologyCategory is not equal to "structure".
 *          - If knowledgeType = 'A'.
 *          - POS = 'A%'
 *        Current tokenParser is not an adjective if (est'a de mas porque ya de por si es false.  Pero sirve para documentar?):
 *          - OntologyCategory = "quantity" because in this case adjective acts like constraint 
	 *               for instance in (9,5,9) "margen entero (raras veces lobulado-dentado distalmente)"
		 * 
	     * - Revision History:
	     *     29/03/2015 - Maria Aux. Mora
	     *     
	     * - Arguments (input / output):
	     *      TokenParser  this   // Tokens to be evaluated
	     * 
	     * - Return Values:
	     *    
*/	
	
		Boolean v_isAdjective = false;
		
		if ( (this.getOntologyCategory()!= null && !this.getOntologyCategory().equals("structure")) &&
				( !(this.getKnowledgeType() == null) && (this.getKnowledgeType().substring(0, 1).equals("A")) || 
				  (this.getWordTag() != null && this.getWordTag().substring(0,1).equals("A")) ))
		    v_isAdjective = true;		
		else {
		   if ((this.getOntologyCategory() != null) && (this.getOntologyCategory().equals("structure") || 
				this.getOntologyCategory().equals("character") || this.getOntologyCategory().equals("quantity") ) )
			   // this.getOntologyCategory().equals("growth_form")  deberian ser adjetivos por eso lo quite hay que probar.
			   
		     v_isAdjective = false;

		}    	
		return (v_isAdjective);
	}
	
	public boolean isStructure(){
	// -category == “structure” or category == “growth_form” or type == “E”: 
        Boolean v_isStructure = false; 
	    
        if ( !(this.getKnowledgeType() == null) &&	(this.getKnowledgeType().substring(0, 1).equals("E") || 
        		               this.getKnowledgeType().substring(0, 1).equals("H")))
				v_isStructure = true;		
        else {
	       if ( !(this.getOntologyCategory() == null) && (this.getOntologyCategory().equals("structure")   ) )
	    	   // ||  this.getOntologyCategory().equals("growth_form").  No todas las formas de vida son estructuras.
			  v_isStructure = true;
        }

		return (v_isStructure);
	}
	
		
    public boolean isStructureModifier(){
	//
	Boolean v_isStructureMod = false; 
				
    if ( !(this.getKnowledgeType() == null) &&	this.getKnowledgeType().substring(0, 1).equals("M") )
		v_isStructureMod = true;

    
    return (v_isStructureMod);
    }
	
    
	public boolean isVerb(){
        Boolean v_isVerb = false; 
		
		if ( !(this.isAdjective()) && !(this.isStructure()) && !(this.isStructureModifier() )  && 
				 ((this.getWordTag().substring(0, 1).equals("V")) ||  ( this.getKnowledgeType() != null && this.getKnowledgeType().equals("V")) ) ) 
			v_isVerb = true;

		return (v_isVerb);
	}
	
	public boolean isNumber(){
        Boolean v_isNumber = false; 
		
		if ( (this.getWordTag().substring(0, 1).equals("Z"))) 
			v_isNumber = true;

		return (v_isNumber);
	}
	
	public boolean isDeterminant(){
        Boolean v_isDeterminant = false; 
		
		if ( (this.getWordTag().substring(0, 1).equals("D"))) 
			v_isDeterminant = true;

		return (v_isDeterminant);
	}
	
	public boolean isPronoun(){
        Boolean v_isPronoun = false; 
		
		if ( (this.getWordTag().substring(0, 1).equals("P"))) 
			v_isPronoun = true;

		return (v_isPronoun);
	}	
	
	public boolean isRoot(){
        Boolean v_isRoot = false; 
		
		if ( (this.getTag2().equals("top"))) 
			v_isRoot = true;

		return (v_isRoot);
	}
	
	
	public boolean isAdverb(){
		// quit'e   || ( this.getOntologyCategory() !=null) && this.getOntologyCategory().equals("quantity") 
		
        Boolean v_isAdverb = false; 
		
		if ( (this.getWordTag().substring(0, 1).equals("R")) ||( this.getKnowledgeType()!=null  &&  this.getKnowledgeType().equals("R") )) 
			v_isAdverb = true;
		return (v_isAdverb);
	}
	
	public boolean isUnitofMeasurement(){
        Boolean v_isUnit = false; 
		
		if ( this.getKnowledgeType()!=null  &&  this.getKnowledgeType().equals("U") )  
			v_isUnit = true;
		return (v_isUnit);
	}	
	
	
	public boolean isArea(){
		 Boolean v_isArea = false; 
			
		if ( this.getKnowledgeType()!=null  &&  this.getKnowledgeType().equals("G") )  
			v_isArea = true;
		return (v_isArea);
	}
	
	
	public String getGender () {
		String v_posWordType = this.getWordTag().substring(0, 1);
		
		String v_gender = null;
		
		switch (v_posWordType) {
        case "A":  // Adjective
        	  v_gender = this.getWordTag().substring(3, 4);
        	  break;
        case "D": // Determinant
        	 v_gender = this.getWordTag().substring(3, 4);
             break;
        case "N": // Name
        	 v_gender = this.getWordTag().substring(2, 3);
             break;
        case "V": // Verb
        	 v_gender = this.getWordTag().substring(6, 7);
             break;
        case "P": // Pronoun
        	 v_gender = this.getWordTag().substring(3, 4);
             break;
                
       }
	
	   return (v_gender);
		
	}
	
	
	public String getNumber() {
		String v_posWordType = this.getWordTag().substring(0, 1);
		
		String v_number = null;
		
		switch (v_posWordType) {
        case "A":  // Adjective
        	  v_number = this.getWordTag().substring(4, 5);
        	  break;
        case "D": // Determinant
        	 v_number = this.getWordTag().substring(4, 5);
             break;
        case "N": // Name
        	 v_number = this.getWordTag().substring(3, 4);
             break;
        case "V": // Verb
        	 v_number = this.getWordTag().substring(5, 6);
             break;
        case "P": // Pronoun
        	 v_number = this.getWordTag().substring(4, 5);
             break;
                
       }
	   return (v_number);	
	}
	
	
	public void processStructure(Connection conn, TokenParser previousToken, String tokenConstraint, String otherConstraint) {
        /* Process structure.  If there are more than one structure together the second one must be a modifier but if there are not
		*  character between them. 
		*/
		
//		Timestamp  characterTimestamp = TextDatabase.selectPreviousCharacterTimestampWithSameChunkKey (conn, this);
//		Timestamp  structureTimestamp = TextDatabase.selectPreviousStructureTimestampWithSameChunkKey(conn, this);
	

    	if ( !(previousToken == null) && (previousToken.isStructure()) && this.distance(conn,previousToken) ==0 ) {
			Integer v_structureId = TextDatabase.selectPreviousStructureNoMatterGenusAndNumber(conn, this);
			if (!(v_structureId == null))
		       TextDatabase.updateStructureConstraintById(conn, this, v_structureId, otherConstraint);
		} else {
			TextDatabase.insertStructure(conn, this, tokenConstraint, otherConstraint);
	    }	
	  }

	


	
	public void processNumber(Connection conn,  String measureUnit, TokenParser previousToken, Boolean isArea , String vName,
			String tokenConstraint, String otherConstraint, TokenParser currentToken){
		// Si la undiad de medida viene primero se procesa y luego se incluye el numero por eso se verifica antes si el caracter ya fue incluido.
		/*
		 * Parameters:  
		 *       otherConstraint: includes the value of a preposition that would be processed by other method.  For instance "hasta".  
		 *                        "hasta" could be an indicator of a superior limit.
		 */
		
//		Integer structureId = TextDatabase.selectLastStructure(conn, this);
		
		/* Set TEXT.INDICATOR.USE_PREVIOUS_ASSINED_STRUCTURE to true/1. To relate current preposition with previous structure assigned 
		 * in the same token.  If there is not structure then use the main clause structure.
		*/
/*	    TextDatabase.setUsePreviousAssignedStructureIndicator(conn, 1);
  	    Integer tempStructureId = TextDatabase.setStructureIdAccordingWithUsePreviousAssignedStructure(conn, null, currentToken); 
        if (tempStructureId == null)
        	tempStructureId =  TextDatabase.selectMainStructureId (conn, currentToken.getTaxonDescriptionId(), currentToken.getLineNumber() );       
	*/
		Integer structureId = TextDatabase.selectLastStructure (conn, this);
		
		if ( TextDatabase.characterWasIncluded (conn, this) ) {
			TextDatabase.updateNumber(conn, this, measureUnit, otherConstraint);
		} else {
		    TextDatabase.insertNumber(conn, this, structureId,  measureUnit, isArea, vName, tokenConstraint, otherConstraint);
		} 	
		
	}
	
	/*
	 * public void processNumberBackBack(Connection conn,  String measureUnit, TokenParser previousToken, Boolean isArea , String vName, String tokenConstraint){
		// Si la undiad de medida viene primero se procesa y luego se incluye el numero.
		
		Integer structureId = TextDatabase.selectLastStructure(conn, this);
		
		if ( TextDatabase.characterWasIncluded (conn, this) ) {
			TextDatabase.updateNumber(conn, this, measureUnit);
		} else {
		
	    	if ((previousToken != null ) && (previousToken.isUnitofMeasurement())) {
		    	// If the previous (parent) token category = U (unit of measure)
			   TextDatabase.updateUnitofMeasurewithNumber(conn, this, structureId,  previousToken);
		   } else TextDatabase.insertNumber(conn, this, structureId,  measureUnit, isArea, vName, tokenConstraint);
		} 	
		
	}
	
	 * 
	 */
	

	public void processAdjective(Connection conn, TokenParser previousToken, String tokenConstraint, String adjectiveModifier,
			String otherConstraint) {
		
		// Find the structure related with current adjective.
		Integer structureId = TextDatabase.selectLastStructure(conn, this);
		
		TokenParser previousCharacter = TextDatabase.selectPreviousCharacterWithSameChunkKey(conn, this);
						
		if ( ((previousCharacter != null) && (previousCharacter.getOntologyCategory()!= null) && (this.getOntologyCategory() != null) &&
				(previousCharacter.getOntologyCategory().trim().equals(this.getOntologyCategory().trim()) )  && 
				(this.distance(conn,previousCharacter) == 0)) ||
				((previousCharacter != null) && (previousCharacter.getOntologyCategory() == null) || (this.getOntologyCategory() == null)) 
				 && (this.distance(conn,previousCharacter) == 0)){
			   // If more that one characters are together and the distance between then is equal to zero.    
				
		       TextDatabase.updateCharacterValue(conn, this, previousCharacter.getTokenId(), otherConstraint); 
		}
		else { /* If it is a individual adjective. If the adjective does not exist in text.character (a character could
				   *  be processed with an adverb if they are siblings.) :
				   */
			   // if between a conjunction and characters (adjectives, numbers, etc) there is an structure characters must be associated to this structure.
			      
		//	   if (previousToken.isStructure()){
		//	      TextDatabase.setUsePreviousAssignedStructureIndicator(conn, 0);
		//	   }
			   if (!(TextDatabase.characterWasIncluded(conn, this)))
				   TextDatabase.insertAdjective(conn, this, structureId, tokenConstraint, adjectiveModifier, otherConstraint);				  
			}
	  
	}	
	

	  public void processPreposition(Connection conn, String prepositionString, Timestamp structureTimestamp, Timestamp characterTimestamp,
			  Integer structureId, Integer characterId, String initialPreposition, TokenParser currentToken, String tokenConstraint){
	  		  
	  if (this.isRoot()) {
		  // If this is root => the system must apply the preposition to the first structure 
		  // (i.e. include the complete phrase into the CONSTRAINT_PREPOSITION field).
		  structureId = TextDatabase.selectMainStructureId (conn,  currentToken.getTaxonDescriptionId(),  currentToken.getLineNumber()) ; 		 
		  TextDatabase.updateStructureConstraintPrepositionById(conn, structureId, prepositionString, initialPreposition, currentToken, 
				                                           tokenConstraint);  
	  }	  
	  else {
		  // Apply the preposition to the last character or structure that was processed (using timestamp).
		  if (characterTimestamp != null && structureTimestamp != null ) {
		     if (characterTimestamp.after(structureTimestamp)){
			  
			    TextDatabase.updateCharacterConstraintPrepositionById(conn, characterId, prepositionString, tokenConstraint); 
		     } else {
			  
			     TextDatabase.updateStructureConstraintPrepositionById(conn, structureId, prepositionString, initialPreposition, currentToken, tokenConstraint);
		     }
		  } else { // If only one of the timestamp is not null. 
			 if (characterTimestamp != null){
				 TextDatabase.updateCharacterConstraintPrepositionById(conn, characterId, prepositionString, tokenConstraint); 
			 } else if (structureTimestamp != null) {
			     TextDatabase.updateStructureConstraintPrepositionById(conn, structureId, prepositionString , initialPreposition, currentToken,
			    		                                                  tokenConstraint);
			 }  else {
				 // If none of the time stamp is not null.  
				  // The system must apply the preposition to the last structure 
				  // (i.e. include the complete phrase into the CONSTRAINT_PREPOSITION field).
				  		 
				  TextDatabase.updateStructureConstraintPrepositionById(conn, structureId, prepositionString, initialPreposition, currentToken,
						                   tokenConstraint);  
			 }
		  }
		  
	  }
	  }
	  
	  public void processConjunctionNoChildren(Connection conn, Integer structureId, Integer characterId, String conjunctionString){
	  
		  // Apply the conjunction to the last character or structure that was processed (using the type of currentToken's  right sibling).
		  
		  if (characterId != null ) {
	         TextDatabase.updateCharacterConstraintConjunctionById(conn, characterId, conjunctionString); 
		     } else { if (structureId != null) 
			     TextDatabase.updateStructureConstraintConjunctionById(conn, structureId, conjunctionString);
		     }
		  
	  }
	
	  /*Respaldo  a borrar
	   * 
	   * 		  if (characterTimestamp != null && structureTimestamp != null ) {
		     if (characterTimestamp.after(structureTimestamp)){
			  
			    TextDatabase.updateCharacterConstraintConjunctionById(conn, characterId, conjunctionString); 
		     } else {
			  
			     TextDatabase.updateStructureConstraintConjunctionById(conn, structureId, conjunctionString);
		     }
		  } else { // If some of the time stamp is not null. 
			 if (characterTimestamp != null){
				 TextDatabase.updateCharacterConstraintConjunctionById(conn, characterId, conjunctionString); 
			 } else if (structureTimestamp != null) {
			     TextDatabase.updateStructureConstraintConjunctionById(conn, structureId, conjunctionString);
			 }  
		  }
	   * 
	   */
	  
	  
	  
	  
	  public void processConjunctionOneChild(Connection conn, TokenParser tokenChild,  Integer structureId, Integer characterId, 
			  Boolean applyToStructure, String conjunctionString){
	  
		  
	  if (applyToStructure && structureId != null) {
		  // If current token has a child that is a structure or structure modifier  
		  // then include the conjunction into the BIOLOGICAL_ENTITY.CONSTRAINT_CONJUNCTION field of previous token processed).
		  		 
		  TextDatabase.updateStructureConstraintConjunctionById(conn, structureId, conjunctionString);  
	  }	  
	  else {
		  // Apply the conjunction to the last character  that was processed (using characterId).
		  if (characterId != null && ! applyToStructure ) {			  
			    TextDatabase.updateCharacterConstraintConjunctionById(conn, characterId, conjunctionString); 
		  } 		  
	  }
	  }
	  
	public void  processPrepositionAsOtherConstraint(Connection conn, Integer structureId,  Integer characterId,
			  Timestamp structureTimestamp, Timestamp characterTimestamp){
		// Actualiza el character o estructura anterior para incluir la preposicion como OTHER_CONSTRAINT 
		// (i.e el "a" como indicador que podria formase un rango).  El proximo caracter se inserta 
		// normalmente. 
		
		/*
		 * Parameters:  
		 *     conn       : dabatabase connection.
		 *     structureId: Id of previous structure.
		 *     caracterId : Id of previous inserted character.
		 * 
		 */
		
		 String prepositionString = this.getWordForm();
		  
		 // Apply the preposition to the last character or structure that was processed (using timestamp).
		 if (characterTimestamp != null && structureTimestamp != null ) {
		     if (characterTimestamp.after(structureTimestamp)){
			  
			    TextDatabase.updateCharacterOtherConstraintById(conn, characterId, prepositionString); 
		     } else {
			  
			     TextDatabase.updateStructureOtherPrepositionById(conn, structureId, prepositionString);
		     }
		  } else { // If some of the time stamp is not null. 
			 if (characterTimestamp != null){
				 TextDatabase.updateCharacterOtherConstraintById(conn, characterId, prepositionString); 
			 } else if (structureTimestamp != null) {
			     TextDatabase.updateStructureOtherPrepositionById(conn, structureId, prepositionString);
			 }  else {
				 // If none of the time stamp is not null.  
				  // The system must apply the preposition to the last structure 
				  // (i.e. include the complete phrase into the CONSTRAINT_PREPOSITION field).
				  		 
				  TextDatabase.updateStructureOtherPrepositionById(conn, structureId, prepositionString);  
			 }
		 }
		
	}	
	
	public void  processVerb(Connection conn, String verbString, String verb, String otherConstraint){
		/* Asigna la frase completa del verbo (verbString) a la ultima estructura o caracter que se proceso de acuerdo al indicador
		 * (TEXT.INDICATOR.USE_PREVIOUS_ASSINED_STRUCTURE) y al timestamp de cada registro (estructura o caracter) .  Si el verbo es 
		 * la raiz del arbol asigna todo el chunk a la estructura principal. 
		 */
		
		/*  
		 * Parameters:  
		 *     conn       : dabatabase connection.
		 *  Fecha modificacion:  21 de octubre de 2015    
		 */
		
	/*	 String vGender = null;
	     String vNumber = null;
		
		if (genderAndNumber != null ) {
		   vGender = genderAndNumber.substring(0, 1);
	       vNumber = genderAndNumber.substring(1, 2);
		}
		
		Integer structureId = TextDatabase.selectLastStructureByGenderAndNumber(conn, this, vGender, vNumber);
	*/	  
		/* Select previous structure that part of the same chunk.  If there are not structure structureId = main structure of the clause
		*/
		
	/*	Integer structureIdSameChunk = TextDatabase.selectPreviousStructureSameChunk(conn, this);
	*/	
		Integer structureIdMain = TextDatabase.selectMainStructureId(conn, this.getTaxonDescriptionId(), this.getLineNumber());

		Timestamp  characterTimestamp = TextDatabase.selectPreviousCharacterTimestampWithSameChunkKey (conn, this);
		Timestamp  structureTimestamp = TextDatabase.selectPreviousStructureTimestampWithSameChunkKey(conn, this);
	   	Integer structureId = TextDatabase.selectPreviousStructureNoMatterGenusAndNumber(conn, this);
  	    Integer characterId = TextDatabase.selectPreviousCharacterIdWithSameChunkKey(conn, this);
  	  
  	     // Verify if TEXT.INDICATOR.USE_PREVIOUS_ASSINED_STRUCTURE is true/1. To relate current preposition with previous structure asigned.
	     // For future development:  the system must create a relation of tempStructureId and next structure.
  	     Integer tempStructureId = TextDatabase.setStructureIdAccordingWithUsePreviousAssignedStructure(conn, structureId, this); 
		
		
		// Save the verbString into the last structure or character that was processed (using the field verb).	
	   
		if (this.isRoot()) {
		   // If current token is root => the system must apply the verb to the main structure 
		   // (i.e. include the complete phrase into the CONSTRAINT_VERB field).

	         TextDatabase.updateStructureVerbById(conn, structureIdMain, verbString, verb, otherConstraint);  
		}
	    else {
	      // Apply the verb to the last character or structure that was processed (using timestamp).
		  if (characterTimestamp != null && structureTimestamp != null ) {
		     if (characterTimestamp.after(structureTimestamp)){
		    	 
		    	 TextDatabase.updateCharacterVerbById(conn, characterId, verbString, verb, otherConstraint); 
		    	 
		    } else TextDatabase.updateStructureVerbById(conn, tempStructureId, verbString, verb, otherConstraint);    	
	      } else { 
	    	  // If one of the timestamp is not null. 
			if (characterTimestamp != null){
			   TextDatabase.updateCharacterVerbById(conn, characterId, verbString, verb, otherConstraint); 
		
			} else if (structureTimestamp != null) {
				TextDatabase.updateStructureVerbById(conn, tempStructureId, verbString, verb, otherConstraint);  
				
			}  else {
				// If none of the time stamp is not null.  
			    // The system must apply the verb to the main structure 
			    // (i.e. include the complete phrase into the CONSTRAINT_VERB field).
				TextDatabase.updateStructureVerbById(conn, structureIdMain, verbString, verb, otherConstraint);  
	  		 
			 
			 }
		   }
	    
	    }  
	
	} 	
	
	
	public void processNumberParentesis(Connection conn,  String measureUnit, TokenParser previousToken, Boolean isArea, 
			String leftNumber, String rightNumber, String vName, String tokenConstraint, String otherConstraint, TokenParser currentToken)
	{
		/* Procesa los numeros que tiene parentesis de forma que se generen las lineas de caracteres "atypical_length" y "atypical_with".
		
		* Parameters
		*      otherConstraint: proposition that included in the filed CHARACTER.other_onstraint. 
		*                      This field contents will be processed for other method. For instance "hasta". 
		*                       "Hasta" could be the the superior limit in a range.
        */  		
		Integer structureId = TextDatabase.selectLastStructure(conn, this);
		// Verify if TEXT.INDICATOR.USE_PREVIOUS_ASSINED_STRUCTURE is true/1. To relate current preposition with previous structure asigned.
	    // For future development:  the system must create a relation of tempStructureId and next structure.
 // 	    structureId = TextDatabase.setStructureIdAccordingWithUsePreviousAssignedStructure(conn, structureId, currentToken); 
		
		if (leftNumber != null && !leftNumber.equals("")){
			// Parameters: connection, isIzquierdo, tokenNumber, isArea, range beginning or end, unit of measure. 
			TextDatabase.insertNumbertwithParentesis(conn, true, this, isArea, leftNumber, measureUnit, structureId, vName, tokenConstraint, otherConstraint);
		} else {
			if (rightNumber != null && !rightNumber.equals("")){
				// Parameters: connection, isIzquierdo, tokenNumber, isArea, range beginning or end, unit of measure. 
				TextDatabase.insertNumbertwithParentesis(conn, false, this, isArea, rightNumber, measureUnit, structureId, vName, tokenConstraint, otherConstraint);
			} else{
				processNumber(conn,  measureUnit, previousToken, isArea, vName, tokenConstraint, otherConstraint, currentToken);
			}
		}
		
		
	}
	
	
	public void processDeterminant(Connection conn, TokenParser previousToken, String otherConstraint, TokenParser tokenChild) {
		/* Los Determinantes Indefinidos actuan como modificadores de estruturas y 
		*  Los Articulos determinan el genero y numero de la estructura a la que aplican.    
		*/
		
		Integer structureId = TextDatabase.selectLastStructure(conn, this);
   
		if (this.getWordTag().substring(1, 2).equals("I")) { 
			// Determinant type = I  (Indefinido, i.e. alguno, ninguno, todos, etc) are used as structure modifier.  
			TextDatabase.updateStructureModifierById (conn, this, structureId, otherConstraint);
			
		} else if (previousToken != null &&  previousToken.isStructureModifier()  ) {
	           // If the article is replacing the name and the modifier is defining another structure 
			   // for instances in "las femeninas mas cortas (ie. book_id 1, taxon 4,line_number 7,chunk 3)."
			   TextDatabase.insertStructure(conn, structureId, previousToken, otherConstraint);         
			   
		} else if (tokenChild != null && tokenChild.isAdjective())  {
	           // If the article is replacing the structure name => another structure must be created.
			   // for instances in "las estériles ( usualmente ausentes ) 4-lobuladas ; (ie. book_id 3, taxon 524,line_number 5)."
			   TextDatabase.insertStructure(conn, structureId, tokenChild, otherConstraint);         
			   
		} else if (this.getWordTag().substring(1, 2).equals("A")) { // Articulos
			String v_gender = this.getWordTag().substring(3, 4);
			String v_number = this.getWordTag().substring(4, 5);
			
			TextDatabase.updateStructureGenderNumberById (conn, v_gender, v_number,  structureId);
		  }
	    
	}
	

	public void processPuntuationMark(Connection conn,  TokenParser p_previousToken, String tokenConstraint){
		
		  switch (this.getWordForm().trim()) {
          case "(": 
       	     if (p_previousToken != null && (p_previousToken.isAdjective() || p_previousToken.getWordTag().substring(0, 1).equals("D")   ///determinant
       	    		|| p_previousToken.getWordTag().substring(0, 1).equals("Z")	 ))
         	     TextDatabase.updateCharacterInBrackets (conn, p_previousToken);
       	     
       	     else if ( p_previousToken != null &&  ( p_previousToken.isStructure() || p_previousToken.isStructureModifier()
       	    		|| p_previousToken.getWordTag().substring(0, 1).equals("P")		 ))
       	    	 TextDatabase.updateStructureInBrackets (conn, p_previousToken);
                 
       	     break;
       	     
          case ".": case ",": case ";": case ":":
        	  if ((tokenConstraint != null) && !tokenConstraint.equals(""))
        		  TextDatabase.updateLastTokenWithLastConstraint(conn, p_previousToken, tokenConstraint);
        	  
        	  break;
         
          default: 
                   break;
      }	
		
	}
	
	public Boolean processAdverbAppliedToPreviousCharacter(Connection conn,  TokenParser p_previousToken){
		// Hace dos tipos de insert para mantener el orden de los adverbios cuando hay mas de uno.
		// Actualiza el constraint  del token previo sea character o estructura
		
		Boolean v_success = false;
		Integer v_characterId = null;
		TokenParser theToken;
		
		if (p_previousToken.isAdverb()) {
			
			theToken =  TextDatabase.selectPreviousCharacterWithSameChunkKey(conn, p_previousToken);
			
			if (theToken != null){
		    	v_characterId = theToken.getTokenId();

			    if ((v_characterId !=null) && (v_characterId != 0) ){
			       TextDatabase.updateCharacterConstraintBefore(conn, this, v_characterId);
			       v_success = true;
			    } 
			}    
		}
		else {	
		   v_characterId = TextDatabase.selectPreviousCharacter(conn, p_previousToken);
		   
			if ((v_characterId !=null) && (v_characterId != 0) ){
			    TextDatabase.updateCharacterConstraint(conn, this, v_characterId);
			    v_success = true;
			 }else if (p_previousToken.isStructure()) {
				 Integer structureId = TextDatabase.selectLastStructure(conn, p_previousToken);
				 if (structureId != null && structureId > 0){
					 TextDatabase.updateStructureConstraintWithStringById(conn, this.getWordForm(), structureId);
				 }
			 }
		}
		
		return (v_success);
	}
	
	public void processAdverbAppliedToSibling(Connection conn, TokenParser tokenSibling, String tokenConstraint, String tokenModifier,
			String otherConstraint){
		// Si el tokenSibling existe en text.character no lo inserta y si no existe lo inserta.
	
	    String v_tokenConstraint;
	    
		if ( !(TextDatabase.characterWasIncluded(conn, tokenSibling))) {
		
			// Find the structure related with current adjective.
			Integer structureId = TextDatabase.selectLastStructure(conn, tokenSibling);
			
			if (tokenConstraint != null && !tokenConstraint.equals(""))
				v_tokenConstraint = tokenConstraint + " " + this.getWordForm();
			else
				v_tokenConstraint = this.getWordForm();
			
	       if ( !(structureId == 0) ){
			   TextDatabase.insertAdjective(conn, tokenSibling, structureId, v_tokenConstraint, tokenModifier,otherConstraint);				  
		   }  
		}
		else { 
			// the procedure return a success aknoledge that is not needed in this context.
			Boolean v_success = this.processAdverbAppliedToPreviousCharacter(conn, tokenSibling);
		}
			
		
	}
	
	
  	public void processStructureModifier(Connection conn,  TokenParser p_previousToken, Boolean modifierHasaDeterminantChild, 
  			String tokenConstraint, String otherConstraint){
		// Modifica la estructura anterior si el modifier no tiene un hijo izquierdo que es un determinante (i.e. las femeninas mas peque~nas).
  		
  		Integer structureId, newStructureId;
  		
  		
  		if (!modifierHasaDeterminantChild) {
  			// Update if the structure modifier if both are in the same chunk.  If not create a new structure and update it with the modifier.
  			
  			structureId = TextDatabase.selectPreviousStructureSameChunk(conn, this);
  			if ((structureId != null) && (structureId > 0) ){
  				TextDatabase.updateStructureModifierById(conn, this, structureId, otherConstraint);
  			} else {
  			   structureId = TextDatabase.selectLastStructure(conn, this);
  	           newStructureId = TextDatabase.cloneStructureById(conn, structureId);
  	           TextDatabase.updateStructureModifierById(conn, this, newStructureId, otherConstraint);
  			}
  		} // else (if has a child that is a determinat) -> in this case the system processes the modifier in combination with the determinant. 
	}	
  	
  
}























